using System;

namespace Busines
{
    public class OperacionesMatriciales : IOperacionesMatricias
    {
        public void Inversa(string nombre, string nombreInversa)
        {
            IMatriz A = new Matriz();
            IMatriz S = new Matriz();
            IMatriz AMP = new Matriz();
            int[] Aux;
            // Verificar si la matriz es singular
            if (A.MakeDeterminante(nombre) == 0) throw new Exception("La matriz es singular");
            Aux = new int[A.Count];
            for(int i = 0; i < A.Count; i++)
            {
                for (int j = 0; j < A.Columns; j++)
                    {
                        AMP.Elements[i, j] = A.Elements[i, j];
                    }
                
            }
            // Inicializar matriz aumentada
            AMP.Count = A.Count;
            AMP.Columns = 2 * A.Columns;
            AMP.Elements = new double[AMP.Count, AMP.Columns];
            MakeAMP(A, AMP);
            TriangularINF(AMP, Aux);
            TriangularSup(AMP);
            Ones(AMP);
            S.Count = A.Count;
            S.Columns = A.Count;
            S.Elements = new double[S.Count, S.Columns];
            MakeS(AMP, S, Aux);
            IDirectorio D = new Directorio();
            D.Save(nombreInversa, Mat(S));
            

        }
        public void Multiplicar(string nombre1, string nombre2, string nombreProducto)
        {
            IMatriz A = new Matriz();
            IMatriz B = new Matriz();
            IMatriz C = new Matriz();
            A.Validate(nombre1);
            B.Validate(nombre2);
            if (A.Columns != B.Count) throw new
                     System.Exception("Error el número de columnas de A difiere al número de Filas de B");
            C.Count = A.Count;
            C.Columns = B.Columns;
            C.Elements = new double[C.Count, C.Columns];
            string Mat = MMult(A, B, C);
            IDirectorio ID = new Directorio();
            ID.Save(nombreProducto, Mat);
        }
        public void Potencia(string nombre, int exponente, string nombrePotencia)
        {
            IMatriz A = new Matriz();
            IMatriz S = new Matriz();
            
            A.Validate(nombre);
            if (A.Count != A.Columns ) throw new System.Exception("Error la matriz A no es cuadrada");
            S.Count = A.Count; S.Columns = A.Columns;
            S.Elements = new double[S.Count, S.Columns];
            MatrizUnidad(S);
            S = CalcularPotencia(exponente, A, S);
            Save(S, nombrePotencia);

        }
        public void Suma(string nombre1, string nombre2, string nombresuma, int signo)
        {
            IMatriz A = new Matriz();
            IMatriz B = new Matriz();
            IMatriz C = new Matriz();
            A.Validate(nombre1);
            B.Validate(nombre2);
            if (A.Count != B.Count || A.Columns != B.Columns)
                throw new System.Exception("Error no es posible la suma o resta en estas matrices");
            C.Count = A.Count;
            C.Columns = A.Columns;
            C.Elements = new double[C.Count, C.Columns];
            string Mat = "[\n";
            for (int i =0; i<C.Count; i++)
            {
                for(int j=0; j<C.Columns; j++)
                {
                    C.Elements[i, j] = A.Elements[i, j] + signo * B.Elements[i, j];
                    Mat += C.Elements[i, j] + " ";
                }
                Mat = Mat.Remove(Mat.Length - 1) + ";\n";
            }
            Mat = Mat.Remove(Mat.Length - 2) + "\n]";
            IDirectorio ID = new Directorio();
            ID.Save(nombresuma, Mat);
        }

        private void MatrizUnidad (IMatriz S)
        {
            for (int i=0; i< S.Count; i++)
            {
                for (int j = 0; j < S.Columns; j++)
                    if (i == j) S.Elements[i, j] = 1;
                    else S.Elements[i, j] = 0;
            }
        }
        private Matriz CalcularPotencia(int exp, Matriz A, Matriz S)
        {
            
            for (int i = 0; i < exp; i++)
            {
                Matriz C = new Matriz();
                C.Count = A.Count; C.Columns = A.Columns;
                C.Elements = new double[C.Columns, C.Columns];
                MMult(A,S,C);
                S = C;
            }
            return S;        
        }
        private void Producto(Matriz A, Matriz S)
        {
            for (int i = 0; i < S.Count; i++)
            {
                for (int j = 0; j < S.Count; j++)
                {
                    double r = 0;
                    for (int k = 0; k < S.Count; k++)
                    {
                        r += A.Elements[i, k] * S.Elements[k, j];
                    }
                    S.Elements[i, j] = r;
                }
            }
        }
        private void Save(IMatriz s, string NombrePotencia)
        {
            string Mat = "[\n";
            for ( int i =0; i<s.Count;i++)
            {
                for(int j=0;j<s.Columns; j++)
                {
                    Mat += s.Elements[i, j] + "";
                }
                Mat = Mat.Remove(Mat.Length - 1) + "\n]";
            }
            Mat = Mat.Remove(Mat.Length - 2) + "\n]";
            IDirectorio ID = new Directorio();
            ID.Save(NombrePotencia, Mat);
        }
        private string MMult(IMatriz A,IMatriz B, IMatriz C)
        {
            string Mat = "[\n";
            for(int i = 0; i< C.Count; i++)
            {
                for(int j=0; j<C.Columns,j++)
                {
                    C.Elements[i, j] = 0;
                    for(int k=0;k<A.Columns;k++)
                    {
                        C.Elements[i, j] += A.Elements[i, k] * B.Elements[k, j];
                    }
                    C.Elements[i, j] = Math.Round(C.Elements[i, j], 12);
                    if (Math.Abs(C.Elements[i, j]) < 1E-14) C.Elements[i, j] = 0;
                    Mat += C.Elements[i, j] + "";
                }
                Mat = Mat.Remove(Mat.Length - 1) + ";\n";
            }
            Mat = Mat.Remove(Mat.Length - 2) + "\n]";
            return Mat;
        }
        private void MakeAMP(IMatriz A, IMatriz AMP)
        {
            for (int i = 0; i < A.Count; i++)
            {
                for (int j = 0; j < A.Columns; j++)
                {
                    AMP.Elements[i, j] = A.Elements[i, j];
                    if (i == j) AMP.Elements[i, j + A.Columns] = 1;
                    else AMP.Elements[i, j + A.Columns] = 0;
                }
            }
        }
        private void SwapAmp(int[] Aux, int posM, int pos0)
        {
            int im = -1, i0 = -1;
            for (int i = 0; i < Aux.Length; i++)
            {
                if (Aux[i] == posM) im = i;
                if (Aux[i] == pos0) i0 = i;
            }
            Aux[im] = pos0;
            Aux[i0] = posM;
        }
        private void Swap(IMatriz AMP, int[] Aux, int posM, int pos0)
        {
            SwapAmp(Aux, posM, pos0);
            double aux;
            for (int i = 0; i < AMP.Columns; i++)
            {
                aux = AMP.Elements[pos0, i];
                AMP.Elements[pos0, i] = AMP.Elements[posM, i];
                AMP.Elements[posM, i] = aux;
            }
        }
        
        
        private void HallarMayor(IMatriz AMP, int[] Aux, int pos0)
        {
            int posM = pos0;
            for (int i = pos0; i < AMP.Count; i++)
            {
                if (AMP.Elements[i, pos0] > AMP.Elements[posM, pos0])
                {
                    posM = i;
                }
            }

            // Si el mayor elemento no es el de la fila actual, se realiza el intercambio
            if (posM != pos0)
            {
                Swap(AMP, Aux, posM, pos0);
            }
        }
        private void TriangularINF(IMatriz AMP, int[] Aux)
        {
            for (int i = 0; i < AMP.Count; i++)
            {
                HallarMayor(AMP, Aux, i);
                for (int j = i + 1; j < AMP.Count; j++)
                {
                    double m = AMP.Elements[j, i] / AMP.Elements[i, i];
                    for (int k = 0; k < AMP.Columns; k++)
                    {
                        AMP.Elements[j, k] = AMP.Elements[j, k] - m * AMP.Elements[i, k];
                    }
                }
            }
        }
        private string Mat(IMatriz AMP)
        {
            string Mat = "[\n";
            for (int i = 0; i < AMP.Count; i++)
            {
                for (int j = 0; j < AMP.Columns; j++)
                {
                    Mat += AMP.Elements[i, j] + "";
                }
                Mat = Mat.Remove(Mat.Length - 1) + ";\n";
            }
            Mat = Mat.Remove(Mat.Length - 2) + "\n]";
            return Mat;
        }
        private void TriangularSup(IMatriz AMP)
        {
            for (int i = AMP.Count - 1; i >= 0; i--)
            {
                for (int j = i - 1; j >= 0; j--)
                {
                    double m = AMP.Elements[j, i] / AMP.Elements[i, i];
                    for (int k = 0; k < AMP.Columns; k++)
                    {
                        AMP.Elements[j, k] -= m * AMP.Elements[i, k];
                    }
                }

                // Paso de escalado diagonal
                for (int k = 0; k < AMP.Columns; k++)
                {
                    AMP.Elements[i, k] /= AMP.Elements[i, i];
                }
            }
        }
        private void Ones(IMatriz AMP)
        {
            for (int i = 0; i < AMP.Count; i++)
            {
                double m = AMP.Elements[i, i];
                for (int j = 0; j < AMP.Columns; j++)
                {
                    AMP.Elements[i, j] = AMP.Elements[i, j] /= m;
                }
            }




        }
        private void MakeS(IMatriz AMP, IMatriz S, int[] Aux)
        {
            for (int i = 0; i < AMP.Count; i++)
            {
                for (int j = 0; j < AMP.Count; j++)
                {
                    S.Elements[i, j] = AMP.Elements[i, j + AMP.Count];
                }
            }
        }













    }
     

       

}
